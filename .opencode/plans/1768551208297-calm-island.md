**Goal**
- Make streaming output feel smooth (typewriter-ish) even when upstream delivers large bursts.
- Target cadence: ~33ms UI updates.
- Also reduce UI jank by batching transcript writes (no per-chunk disk flush).

**Current Behavior / Root Cause**
- `lua/ghost/response.lua` rewrites the entire response buffer (`nvim_buf_set_lines(0, -1, ...)`) on *every* `text_chunk`.
- Upstream may deliver many chunks in one Neovim `on_stdout` callback; the UI work piles up and then redraws in clumps.
- `lua/ghost/receiver.lua` calls `transcript.flush_response_buffer()` on every chunk, causing synchronous disk IO during streaming.

**Approach (Recommended)**

**1) Typewriter Renderer + Debounced Flush (UI)**
- Files:
  - `lua/ghost/response.lua`
- Add a small “render scheduler” inside the response display:
  - Maintain `state.pending_text` (or `state.pending_chunks` table) to buffer incoming `text_chunk`s.
  - Start a repeating timer at 33ms while streaming (stop when idle).
  - On each tick, move a bounded amount of data from pending → state lines.
    - Use newline-aware splitting (avoid per-char `..` concatenation):
      - Split incoming chunk by `\n`.
      - Append first segment to `state.current_line`.
      - Push completed lines into `state.lines`.
    - For the “typewriter” feel without huge latency:
      - Consume up to `MAX_CHARS_PER_TICK` per tick (adaptive based on backlog), e.g. 256–2048 chars/tick.
      - This keeps updates steady while still catching up quickly.
- Rendering strategy (avoid full-buffer rewrites):
  - Track what has already been rendered to the Neovim buffer:
    - `state.rendered_lines` = number of committed `state.lines` already in the buffer
    - `state.rendered_has_current` = whether the buffer currently includes `state.current_line` as the last line
  - Incremental buffer updates:
    - If new committed lines were appended: append them with `nvim_buf_set_lines(buf, start, start, false, new_lines)`.
    - Update only the last line for `state.current_line` changes.
    - Scroll cursor to bottom only when window is open.
  - Fallback to full redraw only when necessary (e.g. after `M.clear()`, `M.load_transcript()`, or if invariants break).
- Window hidden behavior:
  - If response window is hidden, still accumulate into state, but skip expensive buffer ops.
  - When user reopens, do one full redraw.

**2) Batch Transcript Writes (Reduce Jank)**
- Files:
  - `lua/ghost/receiver.lua`
  - `lua/ghost/transcript.lua`
- Stop flushing transcript on every chunk:
  - Replace unconditional `transcript.flush_response_buffer(target_session_id)` with a new helper like:
    - `transcript.maybe_flush_response_buffer(session_id)`
- Implement batching policy inside transcript module (no user-facing config knobs):
  - Use a per-session buffer with size tracking.
  - Flush when either:
    - buffer size >= ~4KB (threshold), OR
    - last flush >= ~250ms ago (timer-based), OR
    - completion event arrives.
  - Also flush before writing tool-call/status/error entries (keep existing behavior).
- Optional (performance): represent `response_buffers[session_id]` as `{ chunks = {}, bytes = N }` instead of repeated string concatenation.

**3) Keep Tool Call Updates Correct**
- File:
  - `lua/ghost/response.lua`
- Tool call lines can modify earlier lines; handle without full redraw:
  - When a tool call line is updated and already rendered, update only that line in the buffer with `nvim_buf_set_lines` for the specific index.
  - When a new tool call line is appended, treat it as appended committed lines (covered by incremental append logic).

**Implementation Steps**
1) Add render queue + timer in `lua/ghost/response.lua`.
2) Refactor `append_text()` to enqueue text and return quickly.
3) Add `flush_pending()` (timer tick) that:
   - consumes a bounded number of chars from the queue,
   - updates `state.lines/current_line`,
   - performs incremental buffer updates.
4) Update tool-call rendering to use targeted line updates where possible.
5) Update transcript flow:
   - add `maybe_flush_response_buffer()` in `lua/ghost/transcript.lua`,
   - modify `lua/ghost/receiver.lua` to call `maybe_flush...` instead of `flush...` per chunk,
   - ensure `handle_complete()` still does a hard flush.

**Completion Criteria**
- Streaming large bursts no longer appear as “bulk dumps”; response advances steadily at ~33ms cadence.
- No visible stutter from per-chunk transcript disk writes.
- Tool call status lines still update correctly during streaming.

**Verification / Tests**
- Manual:
  - In Neovim:
    1) `:lua require('ghost.test').test_response_display()` and modify it to append a large chunk at once; verify it animates smoothly.
    2) `:lua require('ghost.test').test_full_flow('Write ~2000 words on X')` and observe steady streaming.
  - Verify transcript file updates during streaming:
    - Start a long response, wait a second, then inspect transcript file; it should contain partial output (batched), not only final.
- Regression:
  - `:lua require('ghost.test').unit_tests()` (should still pass).

**Notes / Non-Goals**
- Not changing the ACP transport (stdio JSON-RPC) framing in this pass.
- No new `setup()` knobs per request; constants live in modules with sane defaults.
